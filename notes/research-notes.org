#+TITLE: Research Notes
* Data loading
** Source format
Adaptive Biotechnologies makes the raw data available as a zip archive at [[https://s3-us-west-2.amazonaws.com/publishedproject-supplements/emerson-2017-natgen/emerson-2017-natgen.zip]].
The dataset consists of one TSV file per patient with each sequence as a row.
Confusingly, some of the fields appear to be per-patient metadata that is repeated on each row.

#+BEGIN_SRC txt :noweb yes :exports none :tangle ../tools/requirements.txt
<<requirements>>
#+END_SRC

#+BEGIN_SRC txt :noweb-ref requirements :exports code
pandas
#+END_SRC

#+NAME: load_data
#+CAPTION: =../tools/load_dataframe.py=
#+BEGIN_SRC python :tangle ../tools/load_dataframe.py :exports code
import pandas as pd

sample_names = '''rearrangement amino_acid frame_type rearrangement_type
templates reads frequency productive_frequency cdr3_length v_family
v_gene v_allele d_family d_gene d_allele j_family j_gene j_allele
v_deletions d5_deletions d3_deletions j_deletions n2_insertions
n1_insertions v_index n1_index n2_index d_index j_index v_family_ties
v_gene_ties v_allele_ties d_family_ties d_gene_ties d_allele_ties
j_family_ties j_gene_ties j_allele_ties sequence_tags v_shm_count
v_shm_indexes antibody sample_name species locus product_subtype
kit_pool total_templates productive_templates outofframe_templates
stop_templates dj_templates
total_rearrangements productive_rearrangements outofframe_rearrangements
stop_rearrangements dj_rearrangements total_reads
total_productive_reads total_outofframe_reads total_stop_reads
total_dj_reads productive_clonality productive_entropy
sample_clonality sample_entropy sample_amount_ng
sample_cells_mass_estimate fraction_productive_of_cells_mass_estimate
sample_cells fraction_productive_of_cells max_productive_frequency
max_frequency counting_method primer_set release_date sample_tags
fraction_productive order_name kit_id total_t_cells'''.split()

def load_dataframe(filename):
    return pd.read_csv(filename,
                       sep='\t',
                       header=None,
                       names=sample_names,
                       index_col=False,
                       na_values=['unresolved'])

cdr3_v_j = ['amino_acid', 'j_family', 'j_gene', 'j_allele', 'v_family', 'v_gene', 'v_allele']
#+END_SRC

*** Here is a 1mb sample of the raw data (both cohorts).
#+BEGIN_SRC python :session sample :noweb yes :exports none
<<load_dataframe>>
#+END_SRC

#+RESULTS[a64d2268d5812a0e11b86288b04545af308dff04]:

#+BEGIN_SRC python :session sample :exports both
sample = load_dataframe('../misc/1mb_sample.tsv')
sample[cdr3_v_j]
#+END_SRC

#+RESULTS[eb3ba7a1a52d0e39f97e2e5d77ef7824d2e01e1d]:
#+begin_example
            amino_acid j_family      j_gene  j_allele v_family      v_gene  v_allele
0       CASSRTGPGNTIYF  TCRBJ01  TCRBJ01-03       1.0  TCRBV05  TCRBV05-04       1.0
1    CASSYRANTQGAGEAFF  TCRBJ01  TCRBJ01-01       1.0  TCRBV06         NaN       NaN
2        CASSPRNTGELFF  TCRBJ02  TCRBJ02-02       1.0  TCRBV03         NaN       NaN
3      CASSAITGVDSPLHF  TCRBJ01  TCRBJ01-06       1.0  TCRBV05  TCRBV05-05       1.0
4                  NaN  TCRBJ02  TCRBJ02-02       1.0  TCRBV09  TCRBV09-01       NaN
..                 ...      ...         ...       ...      ...         ...       ...
924                NaN  TCRBJ01  TCRBJ01-04       1.0  TCRBV27  TCRBV27-01       1.0
925       CSATGFNTEAFF  TCRBJ01  TCRBJ01-01       1.0  TCRBV29  TCRBV29-01       1.0
926     CASRLGWGGTEAFF  TCRBJ01  TCRBJ01-01       1.0  TCRBV04  TCRBV04-02       1.0
927      CASSLRLTGELFF  TCRBJ02  TCRBJ02-02       1.0  TCRBV27  TCRBV27-01       1.0
928                NaN  TCRBJ01  TCRBJ01-05       1.0  TCRBV05  TCRBV05-01       1.0

[929 rows x 7 columns]
#+end_example

** Extracting unique TCRB sequences
The paper states that a unique TCRB sequence is defined as a "unique combination of a V gene, a CDR3 amino acid sequence, and a J gene."
They state that this criterion "does imply an identical TCRB protein sequence, although, owing to HLA restriction and the potential to pair with different TCRA chains in different T cells, it does not guarantee that two such receptors will have identical antigen specificities."
They find M = 89,840,865 unique TCRB sequences for the N = 666 subjects in the training cohort.
This is ambiguous with regards to the raw data.
*** Some questions
**** Does it mean that we should ignore V and J alleles and just consider the genes?
I don't think so. Some figures/tables from the paper show an allele (e.g. Supplementary Figure 2b).
**** What about the nucleotide sequence in the =rearrangement= field? Or the TCRD gene or allele? Or any of the other assorted sequence-specific fields?
Are there any sequences without a =rearrangement=?
#+BEGIN_SRC python :session sample :exports both
pd.isna(sample.rearrangement).sum()
#+END_SRC

#+RESULTS[e80536b5f93f1b2aaee3434b4ce89d5ce9f0ebae]:
: 0

**** Not every row has an =amino_acid= sequence. Should these rows be discarded?
How many sequences are missing =amino_acid= fields?
#+BEGIN_SRC python :session sample :exports both
sample[pd.isna(sample.amino_acid)][cdr3_v_j]
#+END_SRC

#+RESULTS[ee7484bcc0c7af6061eac28468e39f3fd7d699dc]:
#+begin_example
    amino_acid j_family      j_gene  j_allele v_family      v_gene  v_allele
4          NaN  TCRBJ02  TCRBJ02-02       1.0  TCRBV09  TCRBV09-01       NaN
36         NaN  TCRBJ02  TCRBJ02-03       1.0  TCRBV28  TCRBV28-01       1.0
56         NaN  TCRBJ02  TCRBJ02-04       1.0  TCRBV07  TCRBV07-09       NaN
63         NaN  TCRBJ02  TCRBJ02-07       1.0  TCRBV20         NaN       NaN
65         NaN  TCRBJ02  TCRBJ02-07       1.0  TCRBV24         NaN       NaN
..         ...      ...         ...       ...      ...         ...       ...
909        NaN  TCRBJ02  TCRBJ02-01       1.0  TCRBV12         NaN       NaN
911        NaN  TCRBJ02  TCRBJ02-03       1.0  TCRBV06  TCRBV06-08       1.0
916        NaN  TCRBJ02  TCRBJ02-04       1.0  TCRBV03         NaN       NaN
924        NaN  TCRBJ01  TCRBJ01-04       1.0  TCRBV27  TCRBV27-01       1.0
928        NaN  TCRBJ01  TCRBJ01-05       1.0  TCRBV05  TCRBV05-01       1.0

[129 rows x 7 columns]
#+end_example

**** Some rows don't have V and J alleles (+not sure about genes+ some sequences only have a family). Should these rows be discarded?
No. Looking at Supplementary Table 2, there are V genes listed with only a family, family+gene, and family+gene+allele.
In the sample data, there are very few J genes without gene or allele data.
#+BEGIN_SRC python :session sample :exports both
[pd.isna(sample[c]).sum() for c in ['j_family', 'j_gene', 'j_allele']]
#+END_SRC

#+RESULTS[dcfc703e1dc0dff2c89cce9bc36d66ecbb2abbc3]:
| 0 | 1 | 1 |

It is much more common for V genes to have missing data.
#+BEGIN_SRC python :session sample :exports both
[pd.isna(sample[c]).sum() for c in ['v_family', 'v_gene', 'v_allele']]
#+END_SRC

#+RESULTS[ab986c56285e88849ddee5def4d7be3bc5bce4b4]:
| 1 | 204 | 346 |

**** How should V or J genes be compared if they have different amounts of information (i.e. TCRBV19 vs. TCRBV19-01)? Would this ever arise in practice?
**** Does the =frame_type= field matter?
#+BEGIN_SRC python :session sample :exports both
sample[sample.frame_type != 'In'][['frame_type'] + cdr3_v_j]
#+END_SRC

#+RESULTS[a45de470fb315b32b285ba2ea4f9218b0a22630f]:
#+begin_example
    frame_type         amino_acid j_family      j_gene  j_allele v_family      v_gene  v_allele
4          Out                NaN  TCRBJ02  TCRBJ02-02       1.0  TCRBV09  TCRBV09-01       NaN
36         Out                NaN  TCRBJ02  TCRBJ02-03       1.0  TCRBV28  TCRBV28-01       1.0
46        Stop  CATSRDL*DRDHSPLHF  TCRBJ01  TCRBJ01-06       1.0  TCRBV15  TCRBV15-01       1.0
56         Out                NaN  TCRBJ02  TCRBJ02-04       1.0  TCRBV07  TCRBV07-09       NaN
63         Out                NaN  TCRBJ02  TCRBJ02-07       1.0  TCRBV20         NaN       NaN
..         ...                ...      ...         ...       ...      ...         ...       ...
909        Out                NaN  TCRBJ02  TCRBJ02-01       1.0  TCRBV12         NaN       NaN
911        Out                NaN  TCRBJ02  TCRBJ02-03       1.0  TCRBV06  TCRBV06-08       1.0
916        Out                NaN  TCRBJ02  TCRBJ02-04       1.0  TCRBV03         NaN       NaN
924        Out                NaN  TCRBJ01  TCRBJ01-04       1.0  TCRBV27  TCRBV27-01       1.0
928        Out                NaN  TCRBJ01  TCRBJ01-05       1.0  TCRBV05  TCRBV05-01       1.0

[144 rows x 8 columns]
#+end_example

When =frame_type= is "Out," is =amino_acid= always =NaN=?
#+BEGIN_SRC python :session sample :exports both
(pd.isna(sample.amino_acid) == (sample.frame_type == 'Out')).all()
#+END_SRC

#+RESULTS[32c954041fa4118ca8b3e90de427ad56f0ce1026]:
: True

When =frame_type= is "Stop," does =amino_acid= always contain a =*=? What does this mean?
#+BEGIN_SRC python :session sample :exports both
(sample.amino_acid.str.contains('\*').fillna(False) == (sample.frame_type == 'Stop')).all()
#+END_SRC

#+RESULTS[752f81d79e8dab463effbd3de0e29641d2ea1635]:
: True

**** What about =rearrangement_type= (shouldn't it always be VDJ recombination)?
#+BEGIN_SRC python :session sample :exports both
sample[sample.rearrangement_type != 'VDJ'][['rearrangement_type'] + cdr3_v_j]
#+END_SRC

#+RESULTS[0bd73466cb0a9d6993b1cd5ac61dae416597f38c]:
:     rearrangement_type    amino_acid j_family      j_gene  j_allele v_family      v_gene  v_allele
: 30                  VJ    CAWSDFEQYF  TCRBJ02  TCRBJ02-07       1.0  TCRBV30  TCRBV30-01       1.0
: 85                  VJ    CASSLDTQYF  TCRBJ02  TCRBJ02-03       1.0  TCRBV07  TCRBV07-09       NaN
: 226                 VJ  CATSESTDTQYF  TCRBJ02  TCRBJ02-03       1.0  TCRBV24         NaN       NaN
: 289                 VJ  CASSYSPYEQYF  TCRBJ02  TCRBJ02-07       1.0  TCRBV06  TCRBV06-05       1.0
: 423                 VJ           NaN  TCRBJ01  TCRBJ01-01       1.0  TCRBV04  TCRBV04-03       1.0
: 458                 VJ  CASSSYNSPLHF  TCRBJ01  TCRBJ01-06       1.0  TCRBV19  TCRBV19-01       NaN

**** Should patients with unknown CMV status (25 in cohort 1) be discarded?
Yes. The paper states that "we analyzed each unique TCRB chain identified for the *641 subjects in cohort 1 with known CMV serostatus*" (emphasis added).

*** My plan
**** Load the raw data
Load the fields the paper references as defining a unique sequence (=amino_acid= and =[vj]_{family|gene|allele}=) into PostgreSQL.
Try to do as much filtering as possible in the database, that way I can always restart.
***** User identification
Also include =sample_name= in each row.
For the real data files, there is only one =sample_name= per file.
That should allow the use of one big table at the start.
Don't worry about storing any per-sample data (e.g. CMV serostatus).
That will come later in its own table.
#+BEGIN_SRC python :session sample :exports both
sample['sample_name']
#+END_SRC

#+RESULTS[23762aeb0d8b136871ff822439437d95bc11d9ad]:
#+begin_example
0          HIP00110
1          HIP00169
2          HIP00594
3          HIP00602
4          HIP00614
           ...     
924    Keck0119_MC1
925    Keck0120_MC1
926    Keck0120_MC1
927    Keck0120_MC1
928    Keck0120_MC1
Name: sample_name, Length: 929, dtype: object
#+end_example
***** Loading
#+BEGIN_SRC txt :noweb-ref requirements :exports code
sqlalchemy
psycopg2
#+END_SRC

#+CAPTION: =../tools/populate_db.py=
#+BEGIN_SRC python :tangle ../tools/populate_db.py :exports code
#!/usr/bin/env python3
from load_dataframe import *

from sqlalchemy import create_engine

cols = ['sample_name'] + cdr3_v_j

def populate_db(f, tablename, engine):
    load_dataframe(f)[cols].to_sql(tablename, engine, if_exists='append')

import argparse

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('data_file', type=argparse.FileType('r'))
    parser.add_argument('tablename')
    parser.add_argument('database')

    args = parser.parse_args()
    engine = create_engine(args.database)
    populate_db(args.data_file, args.tablename, engine)

if __name__ == '__main__':
    main()
#+END_SRC
